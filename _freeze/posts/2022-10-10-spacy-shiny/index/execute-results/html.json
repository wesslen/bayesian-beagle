{
  "hash": "dbf35be6f80add25297a8b7ee7be6fe4",
  "result": {
    "markdown": "---\ntitle: \"spaCy in Shiny for Python\"\ndescription: \"Creating an app using spaCy with Shiny for Python\"\ndate: \"10/10/2022\"\ncategories: [vis,spacy]\nimage: \"app.png\"\nimage-alt: \"A Shiny for Python app using spaCy.\"\n---\n\nRecently, RStudio (soon-to-be-renamed, Posit) announced [they're alpha testing an extension of Shiny to Python](https://shiny.rstudio.com/py/)!\n\nSo to learn, I created a prototype for spaCy using Shiny for Python.\n\nIn this post, I want to briefly describe the basics of the app. I'll reference some of the documentation used on the [Shiny for Python documentation](https://shiny.rstudio.com/py/docs/overview.html).\n\n## What makes up a Shiny app?\n\nShiny apps have two major parts that make up an app:\n1. the UI (user-interface)\n2. the Server function\n\nHere's a generic Shiny app for Python:\n\n```python\nfrom shiny import App, ui\n\n# Part 1: ui ----\napp_ui = ui.page_fluid(\n    \"Hello, world!\",\n)\n\n# Part 2: server ----\ndef server(input, output, session):\n    ...\n\n# Combine into a shiny app.\n# Note that the variable must be \"app\".\napp = App(app_ui, server)\n```\n\nTo run this file, we'll need to call `from shiny import App, ui`. And then to create the app itself, we'll combine the ui `app_ui` along with the `server` function into `App()`. Easy so far, right?\n\n## Basics of our spaCy app: Server Side\n\nTo describe my spaCy app (see [code here](https://github.com/wesslen/spacy-shiny)), let's work backwards, starting with the server function first.\n\n```python\ndef server(input, output, session):\n    @output\n    @render.text\n    @reactive.event(input.run) # Take a dependency on the button\n    def result():\n        doc, nlp = process_text(input.spacy_model(), input.text())\n        if \"parser\" in nlp.pipe_names:\n            html_parser = get_parser(doc, nlp)\n        if \"ner\" in nlp.pipe_names:\n            html_ner = get_ner(doc, nlp)\n        return \n```\n\nThe first line is defining the name and arguments for the `server()` function. The next line (`@output`) is a decorator that indicates that the result will be displayed in the UI. Last, the `@reactive.event(input.run)` means that this function will be a dependent event on some input we're calling run `input.run`. We'll explain this in just a second.\n\nWe'll next define a function `result()`, which will result our main server action. The function will call `process_text()`, which is a combination of two helper functions:\n\n```python\ndef load_model(name):\n    return spacy.load(name)\n\ndef process_text(model_name, text):\n    nlp = load_model(model_name)\n    return nlp(text), nlp\n```\n\nThis should be familiar if you've used `spacy` before to [load models](https://spacy.io/api/top-level/#spacy.load) before. Notice that for `process_text()`, we also included a second argument for the `text`. This is what we'll want to revisit in our user interface as this will become reactive based on the user's input.\n\nLast, as two other options, we'll provide two additional helper functions in our `app.py` where we specify what we want to extract from the `doc` object for either `ner` or our parser tagging. The key is we want to use [`displacy`, spaCy's nifty visualizer](https://spacy.io/usage/visualizers) to render either part-of-speech or named entities into the user interface. So to use either, we want to use `display.render()`.\n\nIf we want to use part-of-speech (pos) tagging, we first can separate the document as sentences by using a list comprehension. We do this because displaCy will display pos tags from left to right, and if we have mulitiple sentences than we'll need to scroll. By doing this, we'll stack each pos visualizer vertically, one for each sentence.\n\nWe'll then loop through each sentence, inputting it into `displacy.render()`, adding an additional new line (`\\n`) to improve the cosmetic look with extra vertical space, then format our html output. Notice that for `displacy.render()` we included the argument `style=\"dep\"` to indicate that we were using the [dependency parsing](https://spacy.io/usage/visualizers#dep).\n\n```python\nHTML_WRAPPER = \"\"\"<div style=\"overflow-x: auto; border: 1px solid #e6e9ef; border-radius: 0.25rem; padding: 1rem; margin-bottom: 2.5rem\">{}</div>\"\"\"\n\ndef get_parser(doc, nlp):\n    options = {\n        \"collapse_punct\": True,\n        \"collapse_phrases\": True,\n        \"compact\": True,\n    }\n    docs = [span.as_doc() for span in doc.sents] if True else [doc]\n    for sent in docs:\n        html = displacy.render(sent, style=\"dep\", options=options)\n        html = html.replace(\"\\n\\n\", \"\\n\")\n        html = HTML_WRAPPER.format(html)\n    return html\n```\n\nAlternatively for `ner`, we only need to provide the possible labels as an additional argument for `display.render`, which we can get from `nlp.get_pipe(\"ner\").labels`. We do need to specify that our style is `\"ent\"` as we're interested in [visualizing the entities](https://spacy.io/usage/visualizers#ent). Then we do a similar trick to add white space by replacing blank lines with a new line character (`\\n`) and then format the html with `HTML_WRAPPER.format()`.\n\n```python\nHTML_WRAPPER = \"\"\"<div style=\"overflow-x: auto; border: 1px solid #e6e9ef; border-radius: 0.25rem; padding: 1rem; margin-bottom: 2.5rem\">{}</div>\"\"\"\n\ndef get_ner(doc, nlp):\n    labels = nlp.get_pipe(\"ner\").labels\n    html = displacy.render(doc, style=\"ent\", options={\"ents\": labels})\n    html = html.replace(\"\\n\", \" \")\n    html = HTML_WRAPPER.format(html)\n    return html\n```\n\n## Basics of our spaCy app: UI\n\nWe also have to provide details for the [user interface](https://shiny.rstudio.com/py/docs/user-interface.html) on what to display for our app.\n\nShiny uses a nested layout design for its user interface that typically starts with a `ui.page_fluid()` function that represents the fluid page. YOu can include other components like the `panel_title()` for the panel's title or parts within a sidebar layout.  \n\n```python\napp_ui = ui.page_fluid(\n    ui.panel_title(),\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ...\n        ),\n        ui.panel_main(\n            ...\n        ),\n    ),\n)\n```\n\n::: {.column-margin}\n![Shiny's nested layout design](ui-layout.png)\n:::\n\nWhat's great about `ui` objects is that they are just functions that output html that will be rendered in the user interface.\n\nFor example, let's say we want to see what the `ui.page_fluid()` function does. We can then run the function to see that it simply outputs html code to render the text. \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom shiny import ui\n\nui.page_fluid(\"This is my page\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<html>\n  <head></head>\n  <body>\n    <div class=\"container-fluid\">This is my page</div>\n  </body>\n</html>\n```\n:::\n:::\n\n\nThere are many other `ui` objects that you can create and can provide widgets for your user interface.\n\nFor our interface, we want to provide the user with three options.\n\nFirst, the user can select their model they want to use.\n\nSecond, the user can input as a text box what is the text they want their respective model to analyze.\n\nLast, since shiny implements [reactive programming], we will want to add a button that executes the model select to run on the text provided only when the user clicks a button.\n\nTo do this, we'll use the [documentation for the UI inputs](https://shiny.rstudio.com/py/api/#ui-inputs) and identify that we'll want to use the three functions: \n1. `ui.input_select()`: this will input which spaCy model we'll use\n2. `ui.input_text_area()`: this will input what text we want to process in spaCy\n3. `ui.input_action_button()`: this will be an action button that we'll execute our server function only when this button is selected.\n\n```python\nSPACY_MODEL_NAMES = [\"en_core_web_sm\", \"de_core_news_sm\", \"es_core_news_sm\"]\nDEFAULT_TEXT = \"Tim Cook is the CEO of Apple.\"\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(    \n            ui.input_select(id = \"spacy_model\", label = \"Model name\", choices = SPACY_MODEL_NAMES),\n            ui.input_text_area(id = \"text\", label = \"Text to analyze\", value = DEFAULT_TEXT),\n            ui.input_action_button(\"run\", \"Run doc!\"),\n        ),\n        ui.panel_main(\n            ui.output_ui(\"result\", placeholder=True),\n        ),\n    )\n)\n```\n\nAs a last specification, we want to use the `layout_sidebar()` to include these three inputs in the sidebar of our user interface. We can list each of these three functions inside of the `layout_sidebar()` function. Last, it's important to provide a unique `id` for each of our input functions. We need this as these unique `id` (names) will help us identify the values within the server side.\n\nFor example, recall that we named the reactive event in our server function `@reactive.event(input.run)`. Notice that its input is `input.run`, the name of our `input_action_button`. Hence, this is how we can provide conditional logic for our reactive flow. We only run the `result()` function when the user will click the `input.run` button.\n\nLast, our only missing element is that we need to specify where we are displaying our display output that returned from our server function. For this, we can use the `ui.output_ui()` within the `ui.panel_main()`, which is the main display view of the `ui.layout_sidebar()`. For the user interface to know what is going to be run, we use `result` as the first argument as this is the name of our function within the server-side of the app.\n\nAs a final step, we then combine our UI and server with one final line of code:\n\n```python\napp = App(app_ui, server)\n```\n\nWith all of these details, we can now run our app!\n\n\n```{=html}\n<div style=\"padding-bottom:56.25%; position:relative; display:block; width: 100%\">\n<iframe width=\"100%\" height=\"500px\" style=\"border:2px solid #dee2e6;\" src=\"https://ryanwesslen.shinyapps.io/spacy-shiny/\"></iframe>\n</div>\n```\n\n\n## Deployment\n\nThe app above is a deployed version of app (see [the GitHub repo](https://github.com/wesslen/spacy-shiny)) on [shinyapps.io](https://shinyapps.io/). This is one of the fastest ways to [deploy an app](https://shiny.rstudio.com/py/docs/deploy.html) as this is a cloud service provided by Posit. It provides free and paid tiers depending on your use. For more details about preparing your app for deployment, [check out the deployment docs](https://shiny.rstudio.com/py/docs/deploy.html#configure-python). \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}